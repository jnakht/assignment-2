

1. What is postgreSQL?
PostgreSQL হলো একটি শক্তিশালী, ওপেন-সোর্স অবজেক্ট রিলেশনাল ডেটাবেজ সিস্টেম। এটি মূলত SQL ভাষা ব্যবহার করে এবং এর সাথে অনেক দরকারী বৈশিষ্ট্য যুক্ত করে। এটি ইউনিভার্সিটি অফ ক্যালিফোর্নিয়ার একটি প্রকল্প ছিল এবং তখন POSTGRES নামে পরিচিত ছিল।

এর প্রমাণিত আর্কিটেকচার, নির্ভরযোগ্যতা, শক্তিশালী বৈশিষ্ট্য এবং ওপেন-সোর্স কমিউনিটির নিবেদিত প্রচেষ্টার জন্য মানুষ এটি পছন্দ করে। এটি সমস্ত প্রধান অপারেটিং সিস্টেমে চলে। এটি ২০০১ সাল থেকে ACID কমপ্লায়েন্ট এবং এতে শক্তিশালী এক্সটেনশন রয়েছে।


2. What is the purpose of a database schema in PostgreSQL?
স্কিমা মূলত টেবিল, ভিউ, ইন্ডেক্স, ডেটা টাইপ, ফাংশন, স্টোরড প্রসিডিউর এবং অপারেশনের একটি কালেকশন। এই কালেকশনের একটি নাম থাকে। এই কালেকশন করে রাখলে ডেটাবেজকে গুছিয়ে (organize) রাখতে সুবিধা হয়। একটি ডেটাবেজে এক বা একাধিক স্কিমা থাকতে পারে, কিন্তু একটি স্কিমা শুধুমাত্র একটি ডেটাবেজের অংশ হতে পারে।

দুটি স্কিমার একই নামের অবজেক্ট প্রোপার্টি থাকতে পারে। উদাহরণস্বরূপ, তোমার একটি স্কিমা "students"-এর "parent" নামে একটি টেবিল থাকতে পারে, আবার পাবলিক স্কিমার ভেতরেও "parent" নামের টেবিল থাকতে পারে। সেক্ষেত্রে দুটি আলাদা টেবিলকে এভাবে নির্দেশ করতে হয়:

students.parent

অথবা,

public.parent


তাই আমরা এভাবে বলতে পারি যে:

স্কিমা মূলত ডেটাবেজের অবজেক্টগুলোকে যৌক্তিক গ্রুপে (logical group) ভাগ করতে সাহায্য করে, যাতে আরও বেশি ব্যবস্থাপনার উপযোগী (managable) হয়।
স্কিমার কারণে একটি ডেটাবেজ একাধিক ব্যবহারকারী কোনো সমস্যা ছাড়াই ব্যবহার করতে পারে।


3. Explain the Primary Key and Foreign Key concepts in PostgreSQL.
Primary Key
PostgreSQL-এ Primary Key হলো এক বা একাধিক কলামের সমষ্টি যা প্রতিটি সারিকে আলাদাভাবে চিহ্নিত করতে পারে। প্রতিটি সারিকে আলাদাভাবে চিহ্নিত করা ডেটা ব্যবস্থাপনার একটি অত্যন্ত গুরুত্বপূর্ণ বিষয়। তাই Primary Key-এর দুটি বৈশিষ্ট্য থাকে:

একটি হলো এই কলামের কোনো মান NULL হতে পারবে না, কারণ NULL হলে স্বতন্ত্রভাবে (uniquely) চিহ্নিত করা সম্ভব নয়।
আরেকটি হলো এই কলামের কোনো মান একই হতে পারবে না।
একটি টেবিলে মূলত সর্বোচ্চ একটি Primary Key থাকতে পারে। যদিও একাধিক কলাম একসাথে মিলে একটি Primary Key-এর কাজ করে, তাদের একটি Primary Key ধরা হয়, আর তাদের বলা হয় কম্পোজিট কি (Composite Key)।

Primary Key-এর সিনট্যাক্স হলো:

column_name Data-type PRIMARY KEY

উদাহরণ:
CREATE TABLE STUDENT (
    student_id INTEGER PRIMARY KEY,
    student_name VARCHAR(50),
    student_age INTEGER
);

এখন আমরা চাইলে Primary Key-তে NULL মান ইনসার্ট করতে পারব না।

INSERT INTO student (student_id, student_name, student_age)
VALUES (NULL, 'Jisan Khan', 23); -- error, cannot take null

Primary Key-তে একই মান একবারের বেশি ইনসার্ট করতে পারব না।

INSERT INTO student (student_id, student_name, student_age)
VALUES (1176, 'Jisan Khan', 23);

এখন একই student_id দিয়ে আরেকটি শিক্ষার্থী ইনসার্ট করতে পারব না:
INSERT INTO student (student_id, student_name, student_age)
VALUES (1176, 'Nadim Hasan', 8); -- error

Foreign Key
Foreign Key-এর মৌলিক সংজ্ঞা হলো এমন যে, 'Foreign Key হলো একটি টেবিলের এমন একটি কি (key), যা অন্য টেবিলের Primary Key-কে নির্দেশ করে'। তাহলে সংজ্ঞা থেকে কী বোঝা যাচ্ছে? Foreign Key মূলত দুটি টেবিলের মধ্যে সংযোগ (link) তৈরি করে। যে টেবিলে Primary Key-কে নির্দেশ করা হয়, তাকে বলা হয় 'রেফারেন্সিং টেবিল (referencing table)', আর যে টেবিলের Primary Key-কে নির্দেশ করা হয়, তাকে বলা হয় 'রেফারেন্সড টেবিল (referenced table)'।

Foreign Key কলামে আমরা এমন মান ইনসার্ট করতে পারব যা রেফারেন্সড টেবিলে আছে। এর বাইরে আমরা অন্য কোনো মান ইনসার্ট করতে পারব না। তেমনিভাবে রেফারেন্সড টেবিলের কোনো মান ডিলিট হলে রেফারেন্সিং টেবিলে কী হবে তার জন্য অনেক কনস্ট্রেইন্ট (constraint) আছে। একটি টেবিলে অনেকগুলো Foreign Key থাকতে পারে।

উদাহরণ:

CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    student_name VARCHAR(50),
    student_age INTEGER
);

CREATE TABLE course (
    course_id SERIAL PRIMARY KEY,
    course_name VARCHAR(50)
);

CREATE TABLE enrollment (
    enrollment_id SERIAL PRIMARY KEY,
    student_id REFERENCES students(student_id),
    course_id REFERENCES course(course_id)
);

এখন মান ইনসার্ট করি:

INSERT INTO students (student_id, student_name, student_age)
VALUES
    (1, 'Jisan Khan', 23),
    (2, 'Nadim Hasan', 8);

INSERT INTO course (course_id, course_name)
VALUES
    (1, 'History'),
    (2, 'English Literature');

INSERT INTO enrollment (student_id, course_id)
VALUES (2, 1);

এখন কোনো সমস্যা নেই, কিন্তু যখন আমরা Foreign Key কলামে এমন মান ইনসার্ট করব যেটা রেফারেন্সড টেবিলের Primary Key কলামে নেই, তখন সেটি ত্রুটি (error) দেবে:

INSERT INTO enrollment (student_id, course_id)
VALUES (1162, 1); -- error






4. What is the difference between the VARCHAR and CHAR data types?
CHAR এবং VARCHAR উভয়ই মূলত ক্যারেক্টার টাইপের ভ্যালু স্টোর করার জন্য ব্যবহৃত হয়, কিন্তু তাদের মধ্যে কিছু মৌলিক পার্থক্য আছে।
CHAR:
CHAR ডেটা টাইপ নির্দিষ্ট দৈর্ঘ্যের (fixed length) স্ট্রিং স্টোর করে। মনে করো, আপনি ঠিক ৪টি ক্যারেক্টারের একটি স্ট্রিং স্টোর করতে চান, তাহলে এভাবে ডিক্লেয়ার করতে পারেন CHAR(4)। যদি ৭টি ক্যারেক্টারের একটি স্ট্রিং স্টোর করতে চান, তাহলে এভাবে করতে পারেন CHAR(7), এবং এভাবেই যত ইচ্ছা।

উদাহরণ:

CREATE TABLE student (
    student_id SERIAL PRIMARY KEY,
    blood_group CHAR(2)
);

যখন আমরা আগেই জানতে পারি যে এই কলামের টিউপালে (tuple) কত দৈর্ঘ্যের স্ট্রিং স্টোর করতে হবে, তখন CHAR ব্যবহার করা অনেক সুবিধাজনক।

আবার,
CREATE TABLE student (
    student_id SERIAL PRIMARY KEY,
    student_name CHAR(50)
);

উপরের এই উদাহরণে student_name যদি 'Jisan Khan' হয়, তাহলে এই নামের ১০টি ক্যারেক্টার পূরণ করার পর বাকি ৪০টি স্থান (space) দিয়ে মোট ৫০টি স্থান পূরণ করবে। মানে হলো, CHAR ঠিক যত সাইজের ডিক্লেয়ার করব, ঠিক তত সাইজেরই ডেটা স্টোর করবে।

VARCHAR:
VARCHAR-ও স্ট্রিং স্টোর করার জন্য ব্যবহৃত হয়, তবে VARCHAR স্টোর করার ক্ষেত্রে কিছুটা নমনীয়তা (flexibility) দেয়। একটু আগে বললাম না যে CHAR ঠিক দেওয়া সাইজের স্ট্রিং স্টোর করে, যদিও অতিরিক্ত স্থান দিয়ে পূরণ করা লাগুক না কেন, কিন্তু VARCHAR-এর ক্ষেত্রে কোনো অতিরিক্ত স্থান যোগ করে না। যে স্ট্রিং স্টোর করার জন্য বলা হয়, ঠিক সেই স্ট্রিংটাকেই স্টোর করে।

উদাহরণ:
CREATE TABLE student (
    student_id SERIAL PRIMARY KEY,
    student_name VARCHAR(50)
);

এখন যদি আমরা 'Jisan Khan' নামটি স্টোর করি, এটি এই নামটিকে হুবহু স্টোর করবে, কোনো অতিরিক্ত স্থান দিয়ে মোট ৫০টি ক্যারেক্টার পূরণ করবে না।

তবে এই দুটি ডেটা টাইপের মধ্যে একটি সাধারণ বৈশিষ্ট্য হলো, CHAR(n) এবং VARCHAR(n) কখনোই n সাইজের থেকে বড় স্ট্রিং স্টোর করতে পারবে না।





8. What is the significance of the JOIN operation, and how does it work in PostgreSQL?
দুই বা ততোধিক টেবিলকে একত্রিত করে কোনো অপারেশন করার জন্য JOIN কীওয়ার্ড ব্যবহার করা হয়। আমরা একটু আগেই primary key এবং foreign key আলোচনা করার সময় বলেছিলাম যে, যখন কোনো একটি টেবিলের কলাম অন্য টেবিলের primary key-কে রেফার করে, তখন তাকে foreign key বলা হয়। এখন প্রশ্ন আসতে পারে, এই রেফার করার কাজ কেন করা হয়? আমরা এই রেফার করার কাজটা এইজন্য করি যাতে এই দুই বা তার বেশি টেবিলকে একটি সাধারণ কলামের (common column) মাধ্যমে একত্রিত করতে পারি। ঠিক এই জায়গায় JOIN কীওয়ার্ড ব্যবহার করা হয়।

উদাহরণস্বরূপ, আমাদের কাছে দুটি টেবিল আছে:

students:
------------------------------------
student_id | student_name | course_id
-------------------------------------
01         | Jisan Khan   | 01       |   
02         | Nadim Hasan  | 02       |  
03         | Asif Alom    | 01       |
---------------------------------------    


course:
---------------------------------------------
course_id  |         course_name            | 
----------------------------------------------
01         |    History                     |   
02         | English Literature             |  
---------------------------------------------  


এখন যদি বলা হয়, যার student_id 03, সে কী কোর্স নিয়েছে, তাহলে আমাদের এই দুটি টেবিল JOIN করতে হবে, তাই না? তখন আমরা বলতে পারব যে, যার student_id 03 সে History কোর্স নিয়েছে। এই JOIN করার কাজটা দুটি টেবিলের সাধারণ কলাম course_id-এর মাধ্যমে করব।

JOIN করার প্রকৃতির ওপর নির্ভর করে অনেকভাবে JOIN করার উপায় আছে। এর মধ্যে কিছু সাধারণ JOIN এখানে দেখব:

(i) INNER JOIN
INNER JOIN প্রথম টেবিলের সাথে দ্বিতীয় টেবিলকে JOIN করে যদি সাধারণ কলামে দুটি টেবিলেরই মিলে যাওয়া মান (matching values) থাকে। এক্ষেত্রে এটি প্রথম টেবিলের প্রতিটি সারির সাথে দ্বিতীয় টেবিলের প্রতিটি সারিতে মেলায় এবং দেখে যে সাধারণ কলামে কোথায় মিলে যাওয়া মান আছে, এবং এই মিলে যাওয়া মান দিয়ে দুটি টেবিলকে JOIN করে ফেলে। আর মান না মিললে JOIN করা টেবিলে সেই সারিগুলোকে নেয় না।

উদাহরণ:



students:
------------------------------------
student_id | student_name | course_id
-------------------------------------
01         | Jisan Khan   | 01       |   
02         | Nadim Hasan  | 02       |  
03         | Asif Alom    | 01       |
---------------------------------------    


course:
---------------------------------------------
course_id  |         course_name            | 
----------------------------------------------
01         |    History                     |   
02         | English Literature             |  
03         | Finance Studies                |  
---------------------------------------------  

এখন এই দুটি টেবিলকে INNER JOIN এভাবে করতে পারি:

SELECT student_id, student_name, course_name
FROM students INNER JOIN course
USING(course_id)
ORDER BY student_id;

তাহলে JOIN করা টেবিলটি এমন দেখাবে:


-------------------------------------------------
student_id | student_name | course_name         |
-------------------------------------------------
01         | Jisan Khan   | History             |   
02         | Nadim Hasan  | English Literature  |  
03         | Asif Alom    | History             |
-------------------------------------------------

এখানে খেয়াল করলে দেখা যাবে course_name "Finance Studies", যার course_id 03, সেটি এই JOIN করা টেবিলে নেই, কারণ students টেবিলের course_id-তে এর কোনো মিলে যাওয়া মান নেই।

 (ii) LEFT JOIN
LEFT JOIN-এর মাধ্যমে যখন দুটি টেবিলকে JOIN করা হয়, তখন এটি প্রথম টেবিলকে প্রথম অগ্রাধিকার দেবে এবং সাধারণ কলামের ওপর ভিত্তি করে দুটি টেবিলকে JOIN করবে। যদি প্রথম টেবিলের সাধারণ কলামের মান দ্বিতীয় টেবিলে পাওয়া যায়, তাহলে সেই মিলে যাওয়া মানকে নেবে; আর মিলে যাওয়া মান না পাওয়া গেলে NULL দ্বারা পূর্ণ করবে।

উদাহরণ:



course:
---------------------------------------------
course_id  |         course_name            | 
----------------------------------------------
01         |    History                     |   
02         | English Literature             |  
03         | Finance Studies                |  
04         | Arts and Culture               |  
---------------------------------------------  


students:
--------------------------------------
student_id | student_name | course_id
--------------------------------------
01         | Jisan Khan   | 01       |   
02         | Nadim Hasan  | 02       |  
--------------------------------------- 


এখন যদি বলা হয় সব কোর্স-এর student_name দেখাতে, তাহলে LEFT JOIN করতে পারি।

SELECT course_id, course_name, student_name
FROM course
LEFT JOIN students
USING(course_id)
ORDER BY course_id;

এটির JOIN করা টেবিলটি এমন দেখাবে:

------------------------------------------------------------------
course_id  |         course_name            |  student_name       |
-------------------------------------------------------------------
01         |    History                     |   Jisan Khan        |
02         | English Literature             |   Nadim Hasan       |
03         | Finance Studies                |   (NULL)            |
04         | Arts and Culture               |   (NULL)            |
-------------------------------------------------------------------

এখানে দেখতে পাচ্ছি, প্রথম টেবিলের সাথে মিল করে দ্বিতীয় টেবিলে মান না থাকলে NULL দ্বারা পূর্ণ করছে।

যদিও এই উদাহরণটি "ইন্ডাস্ট্রি" লেভেলের নয়, কারণ একটি কোর্সে অবশ্যই অনেক শিক্ষার্থী ভর্তি হয়, কিন্তু এক্ষেত্রে ধরে নিলাম যে একটি কোর্সে মাত্র একজন শিক্ষার্থী ভর্তি হতে পারে।



(iii) RIGHT JOIN
RIGHT JOIN পুরোপুরি LEFT JOIN-এর মতোই, কিন্তু এখানে দ্বিতীয় টেবিলকে বেশি অগ্রাধিকার দেওয়া হয়। এর মানে হলো, দ্বিতীয় টেবিলের সাধারণ কলামের সাথে মিলে যাওয়া মানকে রাখা হয়, আর যেখানে মিল পাওয়া যায় না সেখানে NULL দ্বারা পূর্ণ করা হয়।

RIGHT JOIN আমরা আরেকটি উদাহরণের মাধ্যমে দেখব:

মনে করো সিটি ইউনিভার্সিটিতে কোডিং প্রতিযোগিতা হবে, এবং CSE ডিপার্টমেন্ট হেড গ্রুপ করার জন্য বললেন। তিনি বললেন যে, প্রত্যেকটি গ্রুপে একজন ছেলে এবং একজন মেয়ে থাকবে। তোমাকে 2টি টেবিল দেওয়া হয়েছে, একটিতে ছেলেদের নাম, আইডি এবং তার গ্রুপ মেট-এর আইডি আছে, আরেকটিতে মেয়েদের নাম, আইডি এবং তার গ্রুপ মেট-এর আইডি আছে। যাদের গ্রুপ মেট এখনো অ্যাসাইন হয়নি, তাদের গ্রুপ মেট-এর আইডির জায়গায় NULL থাকবে। এখন তোমাকে বলল সব মেয়েদের নাম তার গ্রুপ মেট-এর নামসহ দেখাও।




male_students:
------------------------------------------------------
m_student_id | m_student_name | group_mate_id         |
------------------------------------------------------
1017         |   Jisan Khan   |      1176            |   
1019         |   Nadim Hasan  |      1123            |  
1000         |   Asif Alom    |      1019            |
------------------------------------------------------

female_students
------------------------------------------------------
f_student_id | f_student_name | group_mate_id         |
------------------------------------------------------
1176         |   Jishi Khan   |      1017            |   
1123         |   Faria Hasan  |      1019            |  
1015         |   Mila Akter   |      1029            |
------------------------------------------------------

SELECT f_student_name, m_student_name
FROM male_students
RIGHT JOIN female_students
USING(group_mate_id);

এখানে আউটপুট এমন আসবে:

----------------------------------
f_student_name | m_student_name | 
----------------------------------
Jishi Khan     |   Jisan Khan   |  
Faria Hasan    |   Nadim Hasan  | 
Mila Akter     |     (NULL)     | 
---------------------------------


শেষ সারিতে NULL এসেছে কারণ Mila Akter-এর গ্রুপ মেট-এর আইডি 1029 কিন্তু male_students টেবিলে এই আইডিতে কোনো মান নেই।


(iv) FULL OUTER JOIN
FULL OUTER JOIN দুটি টেবিলের সাধারণ কলামের সব মানকে JOIN করে। যেখানে মিলে যাওয়া মান পায় তাদের JOIN করে, যেখানে মিলে যাওয়া মান পায় না সেখানে NULL দ্বারা পূর্ণ করে। এখানে মনে রাখার বিষয় যে, দুটি টেবিলের সব মানই এই JOIN-এ আসে, কোনো মান বাদ যায় না।

উদাহরণ:


male_students:
------------------------------------------------------
m_student_id | m_student_name | group_mate_id         |
------------------------------------------------------
1017         |   Jisan Khan   |      1176            |   
1019         |   Nadim Hasan  |      1123            |  
1000         |   Asif Alom    |      1019            |
------------------------------------------------------

female_students:
------------------------------------------------------
f_student_id | f_student_name | group_mate_id         |
------------------------------------------------------
1176         |   Jishi Khan   |      1017            |   
1123         |   Faria Hasan  |      1019            |  
1015         |   Mila Akter   |      1029            |
------------------------------------------------------

এখন যদি এই দুটি টেবিলকে FULL OUTER JOIN করি:

select f_student_name, m_student_name
from male_students
FULL OUTER JOIN female_students
using(group_mate_id);


আউটপুট এমন দেখাবে:


----------------------------------
f_student_name | m_student_name | 
----------------------------------
Jishi Khan     |   Jisan Khan   |  
Faria Hasan    |   Nadim Hasan  | 
Mila Akter     |     (NULL)     | 
  (NULL)       |   Asif Alom    | 
---------------------------------

এখানে খেয়াল করলে দেখা যাবে, যাদের মান মিলেছে তাদেরও দিয়েছে, যাদের মান মেলেনি তাদেরও দিয়েছে, কিন্তু NULL দ্বারা পূরণ করেছে।

